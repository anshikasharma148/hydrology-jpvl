'use client';
import React, { useState, useEffect } from 'react';
import {
  AreaChart, Area, Tooltip, XAxis, YAxis, ResponsiveContainer, Legend, Brush
} from 'recharts';
import Navbar from '../../../components/Navbar';
import StationOverview from '../../../components/StationOverview';
import { useParams } from 'next/navigation';
import {
  WiHumidity, WiBarometer, WiDaySunny, WiStrongWind, WiSnow, WiRaindrop, WiDirectionUp
} from 'react-icons/wi';
import { RotateCcw } from 'lucide-react'; // âœ… Added import

const stationStates = {
  'vishnu-prayag': 'Uttarakhand',
  'mana': 'Uttarakhand',
  'binakuli': 'Uttarakhand',
  'vasudhara': 'Uttarakhand'
};

const parameters = ["Temperature", "Pressure", "Humidity", "Wind", "Rain", "Snow"];
const units = {
  Temperature: "Â°C",
  Pressure: "hPa",
  Humidity: "%",
  Rain: "mm",
  Snow: "cm",
  Wind: "km/h"
};

const colors = {
  Temperature: "#ff4c4c",
  Pressure: "#0099cc",
  Humidity: "#4caf50",
  Wind: "#6a1b9a",
  Rain: "#1e88e5",
  Snow: "#fbc02d"
};

const getBackgroundGradient = (temperature) => {
  if (temperature === null || temperature === undefined) return 'from-[#1d3557] to-[#457b9d]';
  if (temperature < 0) return 'from-[#1e3c72] to-[#2a5298]';
  if (temperature < 15) return 'from-[#457b9d] to-[#a8dadc]';
  if (temperature < 30) return 'from-[#f9c74f] to-[#f9844a]';
  return 'from-[#f94144] to-[#f3722c]';
};

export default function StationPage() {
  const { station } = useParams();
  const stationDisplay = station.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  const stateName = stationStates[station] || 'Uttarakhand';

  const [selectedParams, setSelectedParams] = useState(["Temperature"]);
  const [days, setDays] = useState(1);
  const [data, setData] = useState([]);
  const [currentTime, setCurrentTime] = useState(new Date());
  const [isCelsius, setIsCelsius] = useState(true);
  const [liveData, setLiveData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const apiStation = station.replace(/-/g, '_');
        const response = await fetch(`http://115.242.156.230:5000/api/aws-all/${apiStation}`);
        if (!response.ok) throw new Error('Failed to fetch');
        const result = await response.json();

        const now = new Date();
        const end = new Date(now);
        end.setHours(23, 59, 59, 999);

        let start = new Date(now);
        
        if (days === 1) {
          start.setHours(0, 0, 0, 0);
        } else if (days === 2) {
          start.setDate(start.getDate() - 1);
          start.setHours(0, 0, 0, 0);
          end.setDate(end.getDate() - 1);
          end.setHours(23, 59, 59, 999);
        } else if (days === 3) {
          start.setDate(start.getDate() - 2);
          start.setHours(0, 0, 0, 0);
        } else if (days === 7) {
          start.setDate(start.getDate() - 6);
          start.setHours(0, 0, 0, 0);
        } else if (days === 30) {
          start.setDate(start.getDate() - 29);
          start.setHours(0, 0, 0, 0);
        }

        const filtered = result.filter(item => {
          const date = new Date(item.timestamp);
          return date >= start && date <= end;
        });

        const formatted = filtered.map(item => {
          const date = new Date(item.timestamp);
          // Display UTC time directly without conversion
          const timeString = days === 1 || days === 2
            ? date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit', 
                hour12: true,
                timeZone: 'UTC' // Force UTC display
              })
            : date.toLocaleDateString('en-GB', { 
                day: '2-digit', 
                month: 'short',
                timeZone: 'UTC'
              });
          
          return {
            time: timeString,
            Temperature: Math.round(item.temperature),
            Pressure: Math.round(item.pressure),
            Humidity: Math.round(item.humidity),
            Wind: Math.round(item.wind_speed),
            Rain: Math.round(item.rain),
            Snow: Math.round(item.snow),
            WindDirection: item.wind_direction,
            fullDate: date.getTime(),
            originalTime: date // Store original date object
          };
        });

        formatted.sort((a, b) => a.fullDate - b.fullDate);
        setData(formatted);

        const latest = result[result.length - 1];
        setLiveData({
          Temperature: Math.round(latest.temperature),
          Humidity: Math.round(latest.humidity),
          Pressure: Math.round(latest.pressure),
          Wind: Math.round(latest.wind_speed),
          Rain: Math.round(latest.rain),
          Snow: Math.round(latest.snow),
        });
      } catch (err) {
        console.error("Error fetching data:", err);
      }
    };

    fetchData();
  }, [station, days]);
  const [isMobile, setIsMobile] = useState(false);
  const [isLandscape, setIsLandscape] = useState(true);

  useEffect(() => {
    const checkScreen = () => {
      const mobile = window.innerWidth < 768;
      setIsMobile(mobile);

      if (mobile) {
        const landscape = window.innerWidth > window.innerHeight;
        setIsLandscape(landscape);
      } else {
        setIsLandscape(true);
      }
    };

    checkScreen();
    window.addEventListener('resize', checkScreen);
    window.addEventListener('orientationchange', checkScreen);

    return () => {
      window.removeEventListener('resize', checkScreen);
      window.removeEventListener('orientationchange', checkScreen);
    };
  }, []);

  useEffect(() => {
    const interval = setInterval(() => setCurrentTime(new Date()), 60000);
    return () => clearInterval(interval);
  }, []);

  const toggleParam = (param) => {
    setSelectedParams(prev =>
      prev.includes(param)
        ? prev.filter(p => p !== param)
        : [...prev, param]
    );
  };

  const toggleUnit = () => setIsCelsius(prev => !prev);

  const formattedDate = currentTime.toLocaleDateString('en-GB', {
    weekday: 'long', day: '2-digit', month: 'long'
  });
  const formattedTime = currentTime.toLocaleTimeString('en-US', {
    hour: '2-digit', minute: '2-digit', hour12: true
  });

  const temperatureValue = isCelsius && liveData ? liveData.Temperature : liveData ? Math.round((liveData.Temperature * 9) / 5 + 32) : '--';
  if (isMobile && !isLandscape) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-black p-4">
        <div className="text-center bg-gray-900 backdrop-blur-md rounded-3xl p-8 max-w-md border border-gray-700 shadow-2xl">
          <div className="mb-6 flex justify-center">
            <div className="animate-spin-slow">
              <RotateCcw size={64} className="text-blue-400" />
            </div>
          </div>
          <h1 className="text-2xl font-bold text-white mb-4">Orientation Required</h1>
          <p className="text-base text-gray-300 mb-4">
            This application is optimized for landscape viewing on mobile devices.
          </p>
          <div className="bg-blue-600 text-white font-bold py-3 px-6 rounded-full inline-block mb-4">
            Please Rotate to Landscape
          </div>
          <div className="text-sm text-gray-400 mt-4 p-3 bg-gray-800 rounded-lg">
            <p className="mb-2">ðŸ“± <strong>Ensure rotation is enabled:</strong></p>
            <p className="text-xs">â€¢ Check your phone's quick settings</p>
            <p className="text-xs">â€¢ Disable rotation lock if enabled</p>
            <p className="text-xs">â€¢ Keep auto-rotate feature turned on</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className={`min-h-screen bg-gradient-to-b ${getBackgroundGradient(liveData?.Temperature)} pb-20 text-white transition-all duration-700`}>
      <Navbar />

      <div className="pt-28 px-12">
        <div className="w-full bg-[#f0f5ff] text-black rounded-3xl shadow-md p-8 flex justify-between items-center h-[260px]">
          <div className="flex flex-col gap-2">
            <h1 className="text-5xl font-extrabold tracking-wide flex gap-2">
              {stationDisplay.split(' ').map((word, i) => (
                <span key={i}>
                  <span className="text-yellow-500 text-6xl font-bold">{word[0]}</span>
                  {word.slice(1)}
                </span>
              ))}
            </h1>
            <div className="text-xl text-gray-700 font-semibold">{stateName}</div>
            <div className="text-md text-gray-600 font-medium">{formattedDate}, {formattedTime}</div>
          </div>

          <div className="w-[65%] flex flex-wrap justify-center gap-3">
            {liveData && [
              { icon: <WiHumidity />, label: 'Humidity', value: `${liveData.Humidity}%`, color: colors.Humidity },
              { icon: <WiBarometer />, label: 'Pressure', value: `${liveData.Pressure} hPa`, color: colors.Pressure },
              { icon: <WiDirectionUp />, label: 'Wind Dir', value: 'NNE', color: '#a855f7' },
              { icon: <WiStrongWind />, label: 'Speed', value: `${liveData.Wind} km/h`, color: colors.Wind },
              { icon: <WiRaindrop />, label: 'Rain', value: `${liveData.Rain} mm`, color: colors.Rain },
              { icon: <WiSnow />, label: 'Snow', value: `${liveData.Snow} cm`, color: colors.Snow }
            ].map(({ icon, label, value, color }, index) => (
              <div key={index} className="w-[140px] h-[140px] rounded-2xl flex flex-col items-center justify-center text-white font-bold text-center transition-all duration-300 transform hover:scale-105 shadow-md hover:shadow-2xl" style={{
                backgroundColor: color,
                boxShadow: `0 6px 15px -3px ${color}90`
              }}>
                <div className="text-[38px] mb-1">{icon}</div>
                <div className="text-base leading-tight">
                  {label}<br />
                  <span className="text-lg font-semibold">{value}</span>
                </div>
              </div>
            ))}
          </div>

          <div className="flex items-center gap-4 text-right">
            <div className="text-[72px] leading-none font-extrabold flex items-start text-black">
              {temperatureValue}Â°
              <sup className="ml-1 text-base font-medium">
                <span className={`${isCelsius ? 'font-bold text-black' : 'text-gray-500'} cursor-pointer`} onClick={() => setIsCelsius(true)}>C</span>
                <span className="text-gray-500 mx-1">|</span>
                <span className={`${!isCelsius ? 'font-bold text-black' : 'text-gray-500'} cursor-pointer`} onClick={() => setIsCelsius(false)}>F</span>
              </sup>
            </div>
            <WiDaySunny className="text-yellow-400 text-[80px] font-extrabold drop-shadow-sm" />
          </div>
        </div>
      </div>

      <div className="text-center font-semibold text-md mt-6 mb-3 space-x-6">
        {["Today", "Yesterday", "3 days", "7 days", "30 days"].map((label) => {
          const value = label === "Today" ? 1 : label === "Yesterday" ? 2 : label === "3 days" ? 3 : label === "7 days" ? 7 : 30;
          return (
            <span key={label} onClick={() => setDays(value)} className={`cursor-pointer hover:underline ${days === value ? 'text-yellow-400' : 'text-white'}`}>
              {label}
            </span>
          );
        })}
      </div>

      <div className="bg-[#f0f5ff] rounded-3xl shadow-lg p-4 mx-12 text-black">
        <div className="flex flex-wrap gap-4 border-b border-gray-300 mb-4">
          {parameters.map(param => (
            <span
              key={param}
              onClick={() => toggleParam(param)}
              style={{
                borderBottom: selectedParams.includes(param) ? `4px solid ${colors[param]}` : '4px solid transparent',
                color: selectedParams.includes(param) ? colors[param] : '#6b7280',
              }}
              className="text-lg font-semibold cursor-pointer transition pb-1"
            >
              {param}
            </span>
          ))}
        </div>

        <ResponsiveContainer width="100%" height={400}>
          <AreaChart
            data={data}
            margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
            syncId="weatherParams"
          >
            <defs>
              {selectedParams.map(param => (
                <linearGradient key={`gradient-${param}`} id={`color${param}`} x1="0" y1="0" x2="0" y2="1">
                  <stop offset="5%" stopColor={colors[param]} stopOpacity={0.8}/>
                  <stop offset="95%" stopColor={colors[param]} stopOpacity={0.1}/>
                </linearGradient>
              ))}
            </defs>
            <XAxis 
              dataKey="time" 
              tick={{ fill: '#4b5563' }}
              tickMargin={10}
            />
            <YAxis 
  tick={{ fill: '#4b5563' }}
  tickFormatter={(value) => {
    if (selectedParams.includes('Temperature') && !selectedParams.includes('Humidity')) {
      return `${value}${isCelsius ? 'Â°C' : 'Â°F'}`;
    }
    return `${value}${units[selectedParams[0]] || ''}`;
  }}
/>
            <Tooltip
  content={({ active, payload, label }) => {
    if (!active || !payload || !payload.length) return null;
    
    const utcDate = new Date(payload[0].payload.fullDate);
    const displayTime = utcDate.toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true,
      timeZone: 'UTC'
    });

    return (
      <div className="bg-blue-100 border border-blue-300 rounded-xl p-4 shadow-lg text-sm">
        <p className="font-bold text-blue-900 mb-2">{displayTime}</p>
        {payload.map((entry, index) => {
          let displayValue = entry.value;
          let unit = units[entry.name] || '';
          
          if (entry.name === 'Temperature' && !isCelsius) {
            displayValue = Math.round((entry.value * 9/5) + 32);
            unit = 'Â°F';
          }
          
          return (
            <div key={`item-${index}`} className="mb-1">
              <span style={{ color: colors[entry.name], fontWeight: 600 }}>
                {entry.name}:
              </span>{" "}
              <span className="text-gray-700">
                {displayValue} {unit} {/* Unit moved here */}
                {entry.name === 'Wind' && payload[0]?.payload?.WindDirection && (
                  <span className="ml-1">({payload[0].payload.WindDirection})</span>
                )}
              </span>
            </div>
          );
        })}
      </div>
    );
  }}
/>
            <Legend 
  formatter={(value) => {
    if (value === 'Temperature') {
      return isCelsius ? 'Temperature' : 'Temperature';
    }
    return value;
  }}
/>

            <Brush 
              dataKey="time" 
              height={30} 
              stroke="#409ac7" 
              fill="#f3f4f6"
              tickFormatter={(value) => {
                if (days <= 2) {
                  return value;
                }
                const date = new Date(value);
                return date.toLocaleDateString('en-GB', { 
                  day: '2-digit', 
                  month: 'short',
                  timeZone: 'UTC'
                });
              }}
            />
            
            {selectedParams.map(param => (
  <Area
    key={param}
    type="monotone"
    dataKey={param}
    stroke={colors[param]}
    fill={`url(#color${param})`}
    strokeWidth={2}
    activeDot={{
      r: 6,
      strokeWidth: 2,
      fill: colors[param],
      stroke: '#fff'
    }}
    animationDuration={1000}
    animationEasing="ease-out"
    name={param} // Remove units from name here
  />
))}
          </AreaChart>
        </ResponsiveContainer>
      </div>
      <StationOverview station={station} liveData={liveData} />
    </div>
  );
}